
        public void MakeNounVerbPairsForExcel(bool interactive)
        {
            string[] verbTags = { "VV", "VB", "VBD", "VBG", "VBN", "VBP", "VBZ" };
            var files = Directory.GetFiles(directoryForExtractedTestCases).Where(x => x.Contains("Tagged"));
            var fileCount = 0;
            var stepLevel = 0;
            foreach (var file in files)
            {
                fileCount++;
                var contents = File.ReadAllText(file);
                var finalString = new StringBuilder();
                int currentTestCaseID = -1;
                var allPairs = new List<string>();
                var testCase_NounVerbPair = new List<KeyValuePair<int, List<string>>>();
                var totalLines = contents.Split(new string[] { "\n" }, StringSplitOptions.RemoveEmptyEntries).Count();
                var passedLines = 0;
                //Traversing through lines in tagged file
                foreach (var line in contents.Split(new string[] { "\n" }, StringSplitOptions.RemoveEmptyEntries))
                {

                    var currentTestCaseHeader = "";
                    //IF line is not starting of a test case
                    if (!line.Contains("Test Case ID: "))
                    {
                        stepLevel++;
                        string previousTag = "";
                        string previousWord = "";
                        foreach (var taggedWord in line.Split(new String[] { " " }, StringSplitOptions.RemoveEmptyEntries).Where(x => x.Contains('/')))
                        {
                            string currentWord = taggedWord.Split('/')[0];
                            string currentTag = taggedWord.Split('/')[1];
                            //IF this word is a verb, then store the word as previous word (to be used as the first word in a pair)
                            if (verbTags.Contains(currentTag))
                            {
                                previousTag = currentTag;
                                previousWord = currentWord;
                            }
                            else
                            {
                                //ELSE it can only be a noun, so make a pair using the previous word, and add it in the list AllPairs and finalString
                                //AND also store it in the matrix (KeyValue pair of (testcase,List of pairs))
                                if (!string.IsNullOrEmpty(previousWord))
                                {
                                    var pair = "(" + previousWord.ToLower() + "_" + currentWord.ToLower() + stepLevel + ")";
                                    allPairs.Add(pair);
                                    finalString.Append(pair);
                                    testCase_NounVerbPair.FirstOrDefault(x => x.Key == currentTestCaseID).Value.Add(pair);
                                }
                                else
                                {
                                    previousTag = currentTag;
                                    previousWord = currentWord;
                                }
                            }
                        }
                    }
                    //IF line is starting of a test case, then store the current test case information
                    else
                    {
                        var temp = line.Split(new String[] { ": " }, StringSplitOptions.RemoveEmptyEntries)[1].Split('~')[0];
                        if (temp.Contains("."))
                            currentTestCaseID = Convert.ToInt32(temp.Split('.')[0]);
                        else
                            currentTestCaseID = Convert.ToInt32(temp);
                        testCase_NounVerbPair.Add(new KeyValuePair<int, List<string>>(currentTestCaseID, new List<string>()));
                        currentTestCaseHeader = line;
                        finalString.Append(currentTestCaseHeader + "\n");
                        stepLevel = 0;
                    }
                    finalString.Append("\n");
                    passedLines++;
                    if (interactive)
                    {
                        Console.Write("File # " + fileCount + "/" + files.Count() + ". Progress: ");
                        Console.Out.WriteLine((float)passedLines / (float)totalLines * 100 + "%");
                    }
                }
                List<string> distinctPairs = new List<string>();
                distinctPairs.AddRange(allPairs.Distinct());
                //Save the pairs and testcase IDs with pairs
                WriteUniquePairsAndTestCasesWithPairs(distinctPairs, testCase_NounVerbPair, file, "");
            }
        }























		
        #region Not Required Anymore

        //NO NEED OF THIS AS PARAGRAPH TAG IS ALREADY INCLUDED IN THE FIRST FUNCTION

        public void ExtractMissingTestCases(List<string> files)
        {
            string allFiles = "";
            List<string> notFoundStepTextsIds = new List<string>();
            foreach (var file in files)
            {
                string contents = File.ReadAllText(file);
                HtmlDocument doc = new HtmlDocument();
                doc.LoadHtml(contents);

                // Testcase Disabled
                if (doc.DocumentNode.SelectSingleNode("//head/title").InnerText.ToLower().Contains("testcase disabled"))
                {
                    continue;
                }

                var stepHtml = doc.DocumentNode.SelectSingleNode(".//div[@class='dv']"); //doc.GetElementbyId("steps_text");
                if (stepHtml != null)
                {
                    allFiles += "Test Case ID: " + file.Substring(file.LastIndexOf("id") + 3) + "~" + file + "\n";
                    string steps = "";
                    var secDoc = new HtmlDocument();
                    secDoc.LoadHtml(stepHtml.InnerHtml);
                    if (stepHtml.InnerHtml.Contains("<p>"))
                        foreach (var node in secDoc.DocumentNode.SelectNodes(".//p"))
                        {
                            steps += node.InnerText + " \n";
                        }
                    allFiles += steps + "\n \n \n";
                    Console.WriteLine(steps);
                }
                else { notFoundStepTextsIds.Add(file); }
            }
            Console.In.Read();
        }
        public void FindIfTestCasesMissing(bool interactive)
        {
            bool first = true;
            string contents = File.ReadAllText(fileToSaveExtractedAndTaggedTestCases);
            string[] lines = contents.Split(new string[] { "\n"/*Environment.NewLine*/ }, StringSplitOptions.RemoveEmptyEntries);
            int linesAfterId = 0;
            List<int> emptyCaseIds = new List<int>();
            List<string> emptyCaseAddresses = new List<string>();
            string lastLine = "";
            foreach (var line in lines)
            {
                if (first)
                {
                    first = false;
                    linesAfterId = 0;
                    lastLine = line;
                    continue;
                }
                if (line.Contains("Test Case ID: "))
                {

                    if (linesAfterId < 3)
                    {
                        emptyCaseIds.Add(Convert.ToInt32(lastLine.Split(':')[1].Split('~')[0]));
                        emptyCaseAddresses.Add(lastLine.Split('~')[1]);
                    }
                    linesAfterId = 0;
                    lastLine = line;
                }
                else
                {
                    linesAfterId++;
                }
            }
            if (interactive)
            {
                Console.Out.Write(String.Join(",", emptyCaseIds));
                Console.In.Read();
            }
            ExtractMissingTestCases(emptyCaseAddresses);
        }

        #endregion

        #region NotUsedMultipletPart
        /*
        public void MakeNounVerbMultiplets(bool interactive)
        {
            string[] verbTags = { "VV", "VB", "VBD", "VBG", "VBN", "VBP", "VBZ" };
            var contents = File.ReadAllText(fileToSaveExtractedAndTaggedTestCases);
            var finalString = new StringBuilder();
            int currentTestCaseID = -1;
            var allMultipletsOneList = new List<string>();
            var testCase_NounVerbMultiplets = new List<KeyValuePair<int, List<string>>>();
            var totalLines = contents.Split(new string[] { "\n" }, StringSplitOptions.RemoveEmptyEntries).Count();
            var passedLines = 0;

            foreach (var line in contents.Split(new string[] { "\n" }, StringSplitOptions.RemoveEmptyEntries))
            {
                if (!line.Contains("Test Case ID: "))
                {
                    string previousTag = "";
                    string previousWord = "";
                    List<string> CurrentMultiplet = new List<string>();
                    foreach (var taggedWord in line.Split(new String[] { " " }, StringSplitOptions.RemoveEmptyEntries).Where(x => x.Contains('/')))
                    {
                        string currentWord = taggedWord.Split('/')[0].ToLower();
                        string currentTag = taggedWord.Split('/')[1];
                        //IF this word is a verb, then store the word as previous word (to be used as the first word in a pair)
                        if (verbTags.Contains(currentTag))
                        {


                            CurrentMultiplet = CurrentMultiplet.OrderByDescending(x => x).ToList();
                            var currStr = String.Join("_", CurrentMultiplet);
                            if (!allMultipletsOneList.Contains(currStr) && !string.IsNullOrEmpty(currStr) && currStr.Split('_').Length > 1)
                            {
                                allMultipletsOneList.Add(currStr);
                                testCase_NounVerbMultiplets.FirstOrDefault(x => x.Key == currentTestCaseID).Value.Add(currStr);

                            }
                            else
                            {

                            }

                            CurrentMultiplet = new List<string>();
                            CurrentMultiplet.Add(currentWord);
                            previousWord = currentWord;
                        }
                        else
                        {
                            //ELSE it can only be a noun, so make a pair using the previous word, and add it in the list AllPairs and finalString
                            //AND also store it in the matrix (KeyValue pair of (testcase,List of pairs))
                            if (!string.IsNullOrEmpty(previousWord))
                                CurrentMultiplet.Add(currentWord);


                            //var pair = "(" + previousWord.ToLower() + "_" + currentWord.ToLower() + ")";
                            //allPairs.Add(pair);
                            //finalString.Append(pair);
                            //testCase_NounVerbPair.FirstOrDefault(x => x.Key == currentTestCaseID).Value.Add(pair);
                        }
                    }
                }
                //IF line is starting of a test case, then store the current test case information
                else
                {
                    currentTestCaseID = Convert.ToInt32(line.Split(new String[] { ": " }, StringSplitOptions.RemoveEmptyEntries)[1].Split('~')[0]);
                    testCase_NounVerbMultiplets.Add(new KeyValuePair<int, List<string>>(currentTestCaseID, new List<string>()));
                }
                finalString.Append("\n");
                passedLines++;
                if (interactive)
                {
                    Console.Out.WriteLine((float)passedLines / (float)totalLines * 100 + "%");
                }
            }

            //Save the Multiplets and testcase IDs with pairs
            WriteUniqueMultipletsAndTestCasesWithMultiplets(allMultipletsOneList, testCase_NounVerbMultiplets);
        }
        public bool CheckIfMultipletExists(List<string> Multiplet, List<List<string>> ListToSearch)
        {
            foreach (var list in ListToSearch)
            {
                foreach (var multiplet in Multiplet)
                {
                    if (list.Contains(multiplet))
                        return true;
                }
                //if (list.Count == Multiplet.Count)
                //    if (list.Contains(Multiplet.ElementAt(0)))
                //        return true;
                //if (list.Contains(Multiplet.ElementAt(1)))
                //    return true;
                //if (list.Contains(Multiplet.ElementAt(2)))
                //    return true;
            }
            return false;
        }
        public void WriteUniqueMultipletsAndTestCasesWithMultiplets(List<string> uniquePairs, List<KeyValuePair<int, List<string>>> testId_pair)
        {
            File.WriteAllText(fileToSaveUniqueMultiplets, string.Join(",", uniquePairs));
            StringBuilder fileString = new StringBuilder();
            foreach (var test in testId_pair)
            {
                fileString.Append("id=" + test.Key + "\n");
                fileString.Append(string.Join(",", test.Value));
                fileString.Append("\n");
            }
            File.WriteAllText(fileToSaveTestIdWithUniqueMultiplets, fileString.ToString());

        }
        */
        #endregion














		
        #region Report Statistics on C:\Temp\Mobile-Statistics.txt
        public void FetchExtractedTestIDsGetWholeResultsMySQL()
        {
            var versions = new int[] { 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29 };
            foreach (var v in versions)
            {
                var tests = File.ReadAllLines(@"C:\Temp\SEALab\NLP-Project\ExtractedTestCases\mobile_@@_Rapid-Tagged.txt".Replace("@@", v.ToString()));
                var results = File.ReadAllLines(@"C:\Temp\SEALab\NLP-Project\ExtractedTestCases\mobile_" + v + "_Result.txt");
                var r = new Dictionary<int, bool>();
                List<int> t = new List<int>();
                var compiledResults = new Dictionary<int, bool>();
                foreach (var line in tests.Where(x => x.Contains("Test Case ID: ")))
                {
                    t.Add(Convert.ToInt32(line.Substring(line.IndexOf("ID:") + 3)));
                }
                foreach (var line in results)
                {
                    var temp = line.Replace("[", "").Replace("]", "").Split(' ');
                    r.Add(Convert.ToInt32(temp[0]), Convert.ToBoolean(temp[1]));
                }
                foreach (var test in t)
                {
                    if (r.Any(x => x.Key == test))
                    {
                        var temp = r.Where(x => x.Key == test);
                        compiledResults.Add(temp.FirstOrDefault().Key, temp.FirstOrDefault().Value);
                    }
                    //else
                    //{
                    //    if (!compiledResults.Any(x => x.Key == test))
                    //        compiledResults.Add(test, true);
                    //}
                }
                var testCaseCount = compiledResults.Count();
                var falseCount = compiledResults.Count(x => x.Value == false);
                File.AppendAllLines(@"C:\Temp\Mobile_Statistics.txt", new string[] { "Version:" + v + ", \tTotal Test Cases:" + testCaseCount + "\t, Failed Test Cases:" + falseCount });
            }
        }
        #endregion













		
        #region Old
        public void GetTestCasesFromExtractedCSVs()
        {
            var directoryToSaveTestCases = @"C:\Temp\SEALab\NLP-Project\ExtractedTestCases\";
            var tagger = new MaxentTagger(taggerModelPath);
            var files = Directory.GetFiles(@"C:\Temp\SEALab\NLP-Project\MySqlTests-NewVersions", "*Steps.csv");
            var fileCount = 0.0;
            foreach (var file in files)
            {
                var steps = new StringBuilder();
                var taggedSteps = new StringBuilder();
                var content = File.ReadAllLines(file);
                var lastId = "";
                var lineCount = 0.0;
                foreach (var line in content)
                {
                    if (string.IsNullOrEmpty(line))
                        continue;
                    var l = line.Replace("\"", "");
                    var temp = l.Split(',');
                    int b56 = 0;
                    if (temp.Length > 2 && int.TryParse(temp[1], out b56) && lastId != temp[1])
                    {
                        steps.Append(Environment.NewLine + Environment.NewLine + "Test Case ID: " + temp[1] + Environment.NewLine + Environment.NewLine);
                        taggedSteps.Append(Environment.NewLine + Environment.NewLine + "Test Case ID: " + temp[1] + Environment.NewLine + Environment.NewLine);
                    }
                    else if (temp.Length == 1)
                    {
                        steps.Append(temp[0] + Environment.NewLine);
                        var sentences = MaxentTagger.tokenizeText(new java.io.StringReader(temp[0])).toArray();
                        foreach (ArrayList sentence in sentences)
                        {
                            var tagged = tagger.tagSentence(sentence).ToString();
                            //ONLY FETCH NOUN AND VERB, DISCARD OTHERS
                            taggedSteps.Append(FetchNounAndVerbsOnly(tagged.Substring(1, tagged.Length - 2)) + Environment.NewLine);
                        }
                    }
                    if (temp.Length > 2)
                    {
                        var id = temp[1];
                        lastId = id;
                        var step = temp[2];
                        steps.Append(step + Environment.NewLine);
                        var sentences = MaxentTagger.tokenizeText(new java.io.StringReader(step)).toArray();
                        foreach (ArrayList sentence in sentences)
                        {
                            var tagged = tagger.tagSentence(sentence).ToString();
                            //ONLY FETCH NOUN AND VERB, DISCARD OTHERS
                            taggedSteps.Append(FetchNounAndVerbsOnly(tagged.Substring(1, tagged.Length - 2)) + Environment.NewLine);
                        }
                    }
                    Console.WriteLine("Progress: Line=" + ++lineCount / content.Length * 100 + ",\t File=" + fileCount / files.Length * 100);
                }
                fileCount++;
                File.WriteAllText(directoryToSaveTestCases + @"mobile_" + Regex.Match(file, @"\d+").Value + "_Rapid.txt", steps.ToString());
                File.WriteAllText(directoryToSaveTestCases + @"mobile_" + Regex.Match(file, @"\d+").Value + "_Rapid-tagged.txt", taggedSteps.ToString());
            }
        }
        #endregion









		
        #region CPC Project Part

        #region Not Needed Anymore
        public void MakeIndicesBinary(string product)
        {
            var versions = new int[] { 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29 };
            var genericPathForIndexedTestCases = @"C:\Temp\SEALab\NLP-Project\ExtractedTestCases\CPC\" + ToPascalCase(product) + @"Pairs\@@\";
            var genericPathForBinaryIndexedTestCases = @"C:\Temp\SEALab\NLP-Project\ExtractedTestCases\CPC\" + ToPascalCase(product) + @"Pairs\New\@@\";
            foreach (var version in versions)
            {
                var files = Directory.GetFiles(genericPathForIndexedTestCases.Replace("@@", version.ToString()));
                foreach (var file in files)
                {
                    var content = File.ReadAllText(file).Split(new string[] { " " }, StringSplitOptions.RemoveEmptyEntries);
                    var temp = Enumerable.Repeat(0, 2471).ToArray(); ;
                    foreach (var pairIndex in content)
                    {
                        temp[Convert.ToInt32(pairIndex) - 1] = 1;
                    }
                    if (!Directory.Exists(genericPathForBinaryIndexedTestCases.Replace("@@", version.ToString())))
                        Directory.CreateDirectory(genericPathForBinaryIndexedTestCases.Replace("@@", version.ToString()));
                    var newFileName = genericPathForBinaryIndexedTestCases.Replace("@@", version.ToString()) + Path.GetFileName(file);
                    File.WriteAllText(newFileName, string.Join(" ", temp));
                }
            }
        }
        #endregion
        #endregion






		
        #region OLD Ordering Test Cases to find APFD


        public void ReadUniquePairsAndTestCasesWithPairs(out List<string> uniquePairs, out List<KeyValuePair<int, List<string>>> testId_pair, string path)
        {
            uniquePairs = new List<string>();
            testId_pair = new List<KeyValuePair<int, List<string>>>();
            var testIdPairsContent = "";
            if (string.IsNullOrEmpty(path))
            {
                uniquePairs.AddRange(File.ReadAllText(fileToSaveUniquePairs).Split(','));
                testIdPairsContent = File.ReadAllText(fileToSaveTestIdWithUniquePairs);
            }
            else
            {
                uniquePairs.AddRange(File.ReadAllText(path.Substring(0, path.LastIndexOf("_")) + "_UniquePairs.txt").Split(','));
                testIdPairsContent = File.ReadAllText(path.Substring(0, path.LastIndexOf("_")) + "_Pairs.txt");
            }
            var first = true;
            var previousId = 0;
            List<string> pairs = new List<string>();
            foreach (var line in testIdPairsContent.Split(new string[] { "\n" }, StringSplitOptions.RemoveEmptyEntries))
            {

                if (line.StartsWith("id="))
                {
                    if (first)
                        first = false;
                    else
                    {
                        testId_pair.Add(new KeyValuePair<int, List<string>>(previousId, pairs));
                    }
                    previousId = Convert.ToInt32(line.Split('=')[1]);
                    pairs = new List<string>();
                }
                else
                {
                    if (!string.IsNullOrEmpty(line))
                        pairs.AddRange(line.Split(','));
                }
            }
            if (!testId_pair.Any(x => x.Key == previousId))
            {
                testId_pair.Add(new KeyValuePair<int, List<string>>(previousId, pairs));
            }
        }
        public void OrderForNounVerbPair(bool interactive)
        {
            List<string> uniquePairs;
            List<KeyValuePair<int, List<string>>> testId_pair;
            ReadUniquePairsAndTestCasesWithPairs(out uniquePairs, out testId_pair, "");


            #region Counting Pair Support, Each pair with its count
            List<KeyValuePair<string, int>> pairCounts = new List<KeyValuePair<string, int>>();
            var iCount = 0.0;
            foreach (var pair in uniquePairs)
            {
                iCount++;
                //get count of test cases having this pair
                var count = (from tip in testId_pair
                             where tip.Value.Contains(pair)
                             select tip).Count();
                //storing each pair with its count
                pairCounts.Add(new KeyValuePair<string, int>(pair, count));
                Console.Clear();
                Console.Out.WriteLine("Pair Counting: " + iCount / uniquePairs.Count * 100 + "%");
            }
            //ordering pairs with their counts
            pairCounts = pairCounts.OrderByDescending(x => x.Value).ToList();
            #endregion

            #region Preparing Data for ordering
            //ordering the list of only pairs with the help of the list of pair with counts that was sorted in the previous step
            uniquePairs = (from u in pairCounts
                           join p in uniquePairs on u.Key equals p
                           select u.Key).ToList();

            //taking counts of Pairs with each test case
            var testId_countOfPair = (from p in testId_pair
                                      select new KeyValuePair<int, int>(p.Key, p.Value.Count)).ToList();
            //ordering Test cases by counts
            var sortedTestId_countOfPair = testId_countOfPair.OrderByDescending(x => x.Value).ToList();
            #endregion

            #region Extracting Test Results from the File
            //extracting the results of the test cases of this litmus
            /**********************************************************************/
            /******************************IMPORTANT*******************************/
            /********Go to the result file, and replace § character with ~*********/
            var resultFile = File.ReadAllLines(fileToExtractResultsOfTestCasesFrom);
            var totalFaults = 0;
            //record results in this list, and put true if a test case passes else false for fail or bad test case
            List<KeyValuePair<int, bool>> testResults = new List<KeyValuePair<int, bool>>();
            foreach (var line in resultFile)
            {
                if (line.Contains("id="))
                {
                    var testId = Convert.ToInt32(line.Substring(line.IndexOf("id=") + 3/*for i d =*/).Split('~')[0]);
                    if (line.Substring(0, 10).Contains("Pass"))
                    {
                        testResults.Add(new KeyValuePair<int, bool>(testId, true));
                    }
                    else
                    {
                        totalFaults++;
                        testResults.Add(new KeyValuePair<int, bool>(testId, false));
                    }
                }
            }
            #endregion



            var originalOrder = (from t in testId_pair select t.Key).ToList();

            var faults = testResults.Where(x => x.Value == false);

            var folder = fileToSaveResultForCharts.Substring(0, fileToSaveResultForCharts.LastIndexOf("\\")) + NAPFDConstant.ToString("N2").Replace(".", "");
            if (!Directory.Exists(folder))
                Directory.CreateDirectory(folder);
            var fileToSave = folder + "\\" + fileToSaveResultForCharts.Substring(fileToSaveResultForCharts.LastIndexOf("\\") + 1);

            //File.WriteAllText(fileToSaveResultForCharts, "INITIATING ....................................\n\n");
            File.WriteAllText(fileToSave, "INITIATING ....................................\n\n");
            for (var indexForRandomizingResult = 0; indexForRandomizingResult < 100; indexForRandomizingResult++)
                FindMetrics(80, indexForRandomizingResult, sortedTestId_countOfPair, testId_pair, uniquePairs, testResults, totalFaults, originalOrder, fileToSave);



            //System.Diagnostics.Process.Start(fileToSaveResultForCharts);
            ProcessStartInfo pi = new ProcessStartInfo(fileToSave);
            pi.Arguments = Path.GetFileName(fileToSave);
            pi.UseShellExecute = true;
            pi.WorkingDirectory = Path.GetDirectoryName(fileToSave);
            pi.FileName = @"C:\Program Files (x86)\Notepad++\\notepad++.exe";
            pi.Verb = "OPEN";
            Process.Start(pi);


        }
        public void OrderForNounVerbPairExcel(bool interactive)
        {
            var results = DeserializeResults(@"C:\Temp\SEALab\NLP-Project\ExtractedTestCases\LatestVersions\ExtractedObjectForAllTestResults.txt");

            var files = Directory.GetFiles(directoryForExtractedTestCases).Where(x => x.Contains("UniquePairs"));
            foreach (var file in files)
            {
                List<string> uniquePairs;
                List<KeyValuePair<int, List<string>>> testId_pair;

                ReadUniquePairsAndTestCasesWithPairs(out uniquePairs, out testId_pair, file);
                #region Counting Pair Support, Each pair with its count
                List<KeyValuePair<string, int>> pairCounts = new List<KeyValuePair<string, int>>();
                var iCount = 0.0;
                foreach (var pair in uniquePairs)
                {
                    iCount++;
                    //get count of test cases having this pair
                    var count = (from tip in testId_pair
                                 where tip.Value.Contains(pair)
                                 select tip).Count();
                    //storing each pair with its count
                    pairCounts.Add(new KeyValuePair<string, int>(pair, count));
                    Console.Clear();
                    Console.Out.WriteLine("Pair Counting: " + iCount / uniquePairs.Count * 100 + "%");
                }
                //ordering pairs with their counts
                pairCounts = pairCounts.OrderByDescending(x => x.Value).ToList();
                #endregion

                #region Preparing Data for ordering
                //ordering the list of only pairs with the help of the list of pair with counts that was sorted in the previous step
                uniquePairs = (from u in pairCounts
                               join p in uniquePairs on u.Key equals p
                               select u.Key).ToList();

                //taking counts of Pairs with each test case
                var testId_countOfPair = (from p in testId_pair
                                          select new KeyValuePair<int, int>(p.Key, p.Value.Count)).ToList();
                //ordering Test cases by counts
                var sortedTestId_countOfPair = testId_countOfPair.OrderByDescending(x => x.Value).ToList();
                #endregion

                #region Extracting Test Results from the File
                //extracting the results of the test cases of this litmus
                /******************************IMPORTANT*******************************/
                /********Go to the result file, and replace § character with ~*********/

                var totalFaults = 0;
                List<KeyValuePair<int, bool>> testResults = new List<KeyValuePair<int, bool>>();
                var currentFile = file.Substring(file.LastIndexOf("\\") + 1).Replace("Tagged", "").Split('~');
                var currentProduct = currentFile[0];
                var currentVersion = currentFile[1].Split('_')[0];
                foreach (var result in results.Where(x => x.Product == currentProduct && x.Version == currentVersion))
                {
                    testResults.Add(new KeyValuePair<int, bool>(result.Id, result.Result));
                }
                totalFaults = testResults.Count(x => x.Value == false);
                #endregion



                var originalOrder = (from t in testId_pair select t.Key).ToList();

                var faults = testResults.Where(x => x.Value == false);

                var fileToSaveResultsTo = file.Substring(0, file.LastIndexOf("\\") + 1) + "Results\\APFD" + NAPFDConstant.ToString("N2").Replace(".", "") + "\\" + file.Substring(file.LastIndexOf("\\") + 1, file.LastIndexOf("_") - 1 - file.LastIndexOf("\\")).Replace("Tagged", "") + ".txt";
                if (!Directory.Exists(file.Substring(0, file.LastIndexOf("\\") + 1) + "Results\\APFD" + NAPFDConstant.ToString("N2").Replace(".", "")))
                    Directory.CreateDirectory(file.Substring(0, file.LastIndexOf("\\") + 1) + "Results\\APFD" + NAPFDConstant.ToString("N2").Replace(".", ""));
                File.WriteAllText(fileToSaveResultsTo, "INITIATING ....................................\n\n");
                for (var indexForRandomizingResult = 0; indexForRandomizingResult < 10; indexForRandomizingResult++)
                    FindMetrics(80, indexForRandomizingResult, sortedTestId_countOfPair, testId_pair, uniquePairs, testResults, totalFaults, originalOrder, fileToSaveResultsTo);



                //System.Diagnostics.Process.Start(fileToSaveResultForCharts);
                //ProcessStartInfo pi = new ProcessStartInfo(fileToSaveResultsTo);
                //pi.Arguments = Path.GetFileName(fileToSaveResultsTo);
                //pi.UseShellExecute = true;
                //pi.WorkingDirectory = Path.GetDirectoryName(fileToSaveResultsTo);
                //pi.FileName = @"C:\Program Files (x86)\Notepad++\\notepad++.exe";
                //pi.Verb = "OPEN";
                //Process.Start(pi);

            }


        }

        private void FindMetrics(int litmusNumber, int indexForRandomizingResult, List<KeyValuePair<int, int>> sortedTestId_countOfPair, List<KeyValuePair<int, List<string>>> testId_pair, List<string> uniquePairs, List<KeyValuePair<int, bool>> testResults, int totalFaults, List<int> originalOrder, string fileToSave)
        {
            #region Ordering Test cases
            //Hence the first one with most pairs is my first ranked test case
            var MyRank = new List<int>();
            if (indexForRandomizingResult >= sortedTestId_countOfPair.Count)
                return;
            MyRank.Add(sortedTestId_countOfPair.ElementAt(indexForRandomizingResult).Key);
            //removing it from the list so that it doesn't get ranked again
            //no need to do this as we are already excluding the ranked ones below
            sortedTestId_countOfPair.RemoveAt(indexForRandomizingResult);

            //now I dont want to cover the pairs already covered by my test case, so subtracting them
            //subtracting all the pairs that appear with the previously ranked test case
            var uncoveredPairs = uniquePairs.Except(testId_pair.FirstOrDefault(x => x.Key == MyRank.FirstOrDefault()).Value).ToList();
            var totalPairCounts = uncoveredPairs.Count;
            //now loop on uncovered pairs
            for (var i = 0; uncoveredPairs.Any(); i++)
            {

                var pairNowCovering = uncoveredPairs.FirstOrDefault();
                //and find the testcases covering that pair, exclude the ones already ranked
                var testCaseHavingThisPairAndWithMaxTotalPairs = (from t in testId_pair
                                                                  where t.Value.Contains(pairNowCovering)
                                                                  && !MyRank.Contains(t.Key)
                                                                  select new { t.Key, t.Value.Count });
                //now take the one covering maximum number of pairs
                if (testCaseHavingThisPairAndWithMaxTotalPairs.Any())
                {
                    var testCaseWithMaxTotalPairs = testCaseHavingThisPairAndWithMaxTotalPairs.ToList().OrderByDescending(x => x.Count).FirstOrDefault().Key;
                    MyRank.Add(testCaseWithMaxTotalPairs);
                    sortedTestId_countOfPair.Remove(sortedTestId_countOfPair.FirstOrDefault(x => x.Key == testCaseWithMaxTotalPairs));
                }
                //removing the covered pair so that it doesnt get covered again
                uncoveredPairs.Remove(pairNowCovering);
                if (uncoveredPairs.Count > 0)
                    Console.Out.WriteLine("Ordering Progress: " + (float)i / totalPairCounts * 100 + "%. " + "NAPFD Constant = " + NAPFDConstant.ToString() + ". Iteration = " + indexForRandomizingResult);
            }


            #region Random Prioritization
            //FOR Random ordering
            var randomRanking = new List<int>();
            var randomNumbers = GenerateRandom(originalOrder.Count, 0, originalOrder.Count);
            List<int> alreadyUsedIndexes = new List<int>();
            foreach (var rnd in randomNumbers)
            {
                randomRanking.Add(originalOrder[rnd]);
            }
            #endregion

            //now you will be done with all the pairs but test cases still remaining, so copy them according to their order(counts of pairs included in a test case) in MyRank
            if (sortedTestId_countOfPair.Count > 0)
            {
                MyRank.AddRange((from t in sortedTestId_countOfPair select t.Key).ToList());
            }
            #endregion
            if (string.IsNullOrEmpty(fileToSave))
                File.AppendAllText(fileToSaveResultForCharts, "ITERATION: " + indexForRandomizingResult + " # \n");
            else
                File.AppendAllText(fileToSave, "ITERATION: " + indexForRandomizingResult + " # \n");
            #region Plotting Graph for Percentage of Faults found against test cases
            ///////////////////////////PERCENTAGE OF FAULTS FOUND/////////////////////////////

            //calculating apfd
            var myAPFD = 1.0;
            double[] apfdPrioritizedForIteration = new double[MyRank.Count];
            var indexDetectingFault = 0;
            var loope = 0;
            var faultsDetected = 0.0;
            Dictionary<float, float> faultDetectedPercentage = new Dictionary<float, float>();
            //foreach (var rank in MyRank)
            //{
            //    loope++;
            //    if (testResults.Any(x => x.Key == rank && x.Value == false))
            //    {
            //        faultsDetected++;
            //        indexDetectingFault += loope;
            //        myAPFD = NAPFDConstant - ((float)indexDetectingFault / (float)(totalFaults * MyRank.Count)) + (float)(NAPFDConstant / (float)(2 * MyRank.Count));
            //        faultDetectedPercentage.Add((float)loope / MyRank.Count * 100, (float)faultsDetected / totalFaults);
            //    }
            //    Console.Out.WriteLine((float)loope / MyRank.Count * 100 + "%: " + (float)faultsDetected / totalFaults);
            //}

            var faultCount = testResults.Count(x => x.Value == false);
            foreach (var f in testResults.Where(x => x.Value == false))
            {
                faultsDetected++;
                indexDetectingFault += MyRank.IndexOf(f.Key) + 1;
                myAPFD = NAPFDConstant - ((float)indexDetectingFault / (float)(totalFaults * MyRank.Count)) + (float)(NAPFDConstant / (float)(2 * MyRank.Count));
                //faultDetectedPercentage.Add((float)faultsDetected / MyRank.Count * 100, (float)faultsDetected / totalFaults);
                Console.Out.WriteLine((float)faultsDetected / faultCount * 100 + "%: " + (float)faultsDetected / totalFaults);
                if (faultsDetected / faultCount > NAPFDConstant)
                    break;
            }


            if (string.IsNullOrEmpty(fileToSave))
            {
                File.AppendAllText(fileToSaveResultForCharts, "PAIR METHOD APFD = " + myAPFD + ";\n");
                //File.AppendAllText(fileToSaveResultForCharts, "\t\t\t" + string.Join(",", faultDetectedPercentage) + "\n");
                File.AppendAllText(fileToSaveResultForCharts, "\r\n");
            }
            else
            {
                File.AppendAllText(fileToSave, "PAIR METHOD APFD = " + myAPFD + ";\n");
                //File.AppendAllText(fileToSave, "\t\t\t" + string.Join(",", faultDetectedPercentage) + "\n");
            }

            //indexDetectingFault = 0;
            //loope = 0;
            //faultsDetected = 0.0;
            //faultDetectedPercentage = new Dictionary<float, float>();
            //foreach (var rank in originalOrder)
            //{
            //    loope++;
            //    if (testResults.Any(x => x.Key == rank && x.Value == false))
            //    {
            //        faultsDetected++;
            //        indexDetectingFault += loope;
            //        myAPFD = 1.0 - ((float)indexDetectingFault / (float)(totalFaults * originalOrder.Count)) + (float)(1.0 / (float)(2 * originalOrder.Count));
            //        faultDetectedPercentage.Add((float)loope / originalOrder.Count * 100, (float)faultsDetected / totalFaults);
            //    }
            //    Console.Out.WriteLine((float)loope / originalOrder.Count * 100 + "%: " + (float)faultsDetected / totalFaults);
            //}
            //File.AppendAllText(fileToSaveResultForCharts, "ORIGINAL ORDER APFD = " + myAPFD + "\n");

            indexDetectingFault = 0;
            loope = 0;
            faultsDetected = 0.0;
            faultDetectedPercentage = new Dictionary<float, float>();
            var randomAPFD = 0.0;
            //foreach (var rank in randomRanking)
            //{
            //    loope++;
            //    if (testResults.Any(x => x.Key == rank && x.Value == false))
            //    {
            //        faultsDetected++;
            //        indexDetectingFault += loope;
            //        randomAPFD = NAPFDConstant - ((float)indexDetectingFault / (float)(totalFaults * randomRanking.Count)) + (float)(NAPFDConstant / (float)(2 * randomRanking.Count));
            //        faultDetectedPercentage.Add((float)loope / randomRanking.Count * 100, (float)faultsDetected / totalFaults);
            //    }
            //    Console.Out.WriteLine((float)loope / randomRanking.Count * 100 + "%: " + (float)faultsDetected / totalFaults);
            //}
            foreach (var f in testResults.Where(x => x.Value == false))
            {
                faultsDetected++;
                indexDetectingFault += randomRanking.IndexOf(f.Key) + 1;
                randomAPFD = NAPFDConstant - ((float)indexDetectingFault / (float)(totalFaults * randomRanking.Count)) + (float)(NAPFDConstant / (float)(2 * randomRanking.Count));
                //faultDetectedPercentage.Add((float)faultsDetected / MyRank.Count * 100, (float)faultsDetected / totalFaults);
                Console.Out.WriteLine((float)faultsDetected / faultCount * 100 + "%: " + (float)faultsDetected / totalFaults);
                if (faultsDetected / faultCount > NAPFDConstant)
                    break;
            }
            if (string.IsNullOrEmpty(fileToSave))
            {
                File.AppendAllText(fileToSaveResultForCharts, "RANDOM METHOD APFD = " + randomAPFD + ";\n");
                //File.AppendAllText(fileToSaveResultForCharts, "\t\t\t" + string.Join(",", faultDetectedPercentage) + "\n");
            }
            else
            {
                File.AppendAllText(fileToSave, "RANDOM METHOD APFD = " + randomAPFD + ";\n");
                //File.AppendAllText(fileToSave, "\t\t\t" + string.Join(",", faultDetectedPercentage) + "\n");
            }
            ///////////////////////////PERCENTAGE OF FAULTS FOUND/////////////////////////////
            #endregion



        }











        public void ProcessAllNounsInALitmus()
        {
            var versions = new int[] { 10, 11, 12, 13, 30, 35, 36, 40, 50, 60, 70, 80, 90 };
            var countVersionsProcessed = 0.0;
            var folderNameToSaveAllNounFile = @"C:\Temp\SEALab\NLP-Project\ExtractedTestCases\CPC\Nouns\";
            Dictionary<string, int> indexedNouns = new Dictionary<string, int>();
            var index = 0;
            foreach (var v in versions)
            {
                var genericFileNameToReadLitmusFile = @"C:\Temp\SEALab\NLP-Project\ExtractedTestCases\litmus_@@_TestIdWithNouns.txt".Replace("@@", v.ToString());
                var genericFolderNameToSaveIndexNounFiles = @"C:\Temp\SEALab\NLP-Project\ExtractedTestCases\CPC\Nouns\@@\".Replace("@@", v.ToString());
                var content = File.ReadAllLines(genericFileNameToReadLitmusFile);
                if (!Directory.Exists(genericFolderNameToSaveIndexNounFiles))
                    Directory.CreateDirectory(genericFolderNameToSaveIndexNounFiles);
                var countLinesProcessed = 0.0;
                foreach (var line in content)
                {
                    if (!line.Contains("=Passed") && !line.Contains("=Failed") && !string.IsNullOrEmpty(line))
                    {
                        if (!indexedNouns.Any(x => x.Key == line.Trim()))
                        {
                            indexedNouns.Add(line.Trim(), ++index);
                            //lastTestCaseIndexed += index + " ";
                        }
                    }
                    Console.WriteLine("Progress: Lines Processed=" + countLinesProcessed++ / content.Length * 100 + "%;\tVersions Processed=" + countVersionsProcessed / versions.Length * 100 + "%");

                }

                countVersionsProcessed++;
            }
            File.WriteAllLines(folderNameToSaveAllNounFile + @"AllNounsIndexed.txt", indexedNouns.Select(x => x.Value + " " + x.Key).ToArray());
        }
        public void IndexAllNounsInLitmus()
        {
            var indicesWithNouns = File.ReadAllLines(@"C:\Temp\SEALab\NLP-Project\ExtractedTestCases\CPC\Nouns\AllNounsIndexed.txt");
            Dictionary<string, int> indexedNouns = new Dictionary<string, int>();
            foreach (var line in indicesWithNouns)
            {
                if (!string.IsNullOrEmpty(line))
                {
                    var temp = line.Split(' ');
                    indexedNouns.Add(temp[1], Convert.ToInt32(temp[0]));
                }
            }
 
 
 
 
 
 
 
            var versions = new int[] { 10, 11, 12, 13, 30, 35, 36, 40, 50, 60, 70, 80, 90 };
            var countVersionsProcessed = 0.0;
            foreach (var v in versions)
            {
                var genericFileNameToReadLitmusFile = @"C:\Temp\SEALab\NLP-Project\ExtractedTestCases\litmus_@@_TestIdWithNouns.txt".Replace("@@", v.ToString());
                var genericFolderNameToSaveIndexNounFiles = @"C:\Temp\SEALab\NLP-Project\ExtractedTestCases\CPC\Nouns\@@\".Replace("@@", v.ToString());
                var content = File.ReadAllLines(genericFileNameToReadLitmusFile);
                string lastTestHeader = "";
                string lastTestCaseIndexed = "";
                if (!Directory.Exists(genericFolderNameToSaveIndexNounFiles))
                    Directory.CreateDirectory(genericFolderNameToSaveIndexNounFiles);
                var countLinesProcessed = 0.0;
                foreach (var line in content)
                {
                    if (!line.Contains("=Passed") && !line.Contains("=Failed") && !string.IsNullOrEmpty(line))
                    {
                        lastTestCaseIndexed += indexedNouns[line.Trim()] + " ";
                    }
                    else
                    {
                        if (!string.IsNullOrEmpty(lastTestHeader) && !string.IsNullOrEmpty(lastTestCaseIndexed.Trim()))
                            File.WriteAllText(genericFolderNameToSaveIndexNounFiles + @"\" + lastTestHeader + ".txt", lastTestCaseIndexed.Trim());
                        lastTestHeader = line;
                        lastTestCaseIndexed = "";
                    }
                    Console.WriteLine("Progress: Lines Processed=" + countLinesProcessed++ / content.Length * 100 + "%;\tVersions Processed=" + countVersionsProcessed / versions.Length * 100 + "%");

                }

                countVersionsProcessed++;
            }
        }




        #endregion







		
        //GIVING LOW APFD THAN ORIGINAL AND RANDOM
        #region NounVerbCountCombined
        public void CountNounAndVerbCombined(bool interactive)
        {
            var contents = File.ReadAllText(fileToSaveExtractedAndTaggedTestCases);
            var totalLines = contents.Split(new string[] { "\n" }, StringSplitOptions.RemoveEmptyEntries).Count();
            var passedLines = 0;
            int currentTestCaseID = 0;
            List<KeyValuePair<int, int>> testCaseIdWithCounts = new List<KeyValuePair<int, int>>();
            List<KeyValuePair<int, List<string>>> testCaseIdWithTopics = new List<KeyValuePair<int, List<string>>>();
            var testCaseTopicsCount = 0;
            var testCaseTopics = new List<string>();
            foreach (var line in contents.Split(new string[] { "\n" }, StringSplitOptions.RemoveEmptyEntries))
            {
                if (line.Contains("Test Case ID: "))
                {
                    if (currentTestCaseID != 0)
                    {
                        testCaseIdWithCounts.Add(new KeyValuePair<int, int>(currentTestCaseID, testCaseTopicsCount));
                        testCaseIdWithTopics.Add(new KeyValuePair<int, List<string>>(currentTestCaseID, testCaseTopics));
                        testCaseTopicsCount = 0;
                        testCaseTopics = new List<string>();
                    }
                    currentTestCaseID = Convert.ToInt32(line.Split(new String[] { ": " }, StringSplitOptions.RemoveEmptyEntries)[1].Split('~')[0].Replace(".html", "").Replace(".txt", ""));
                }
                else
                {
                    testCaseTopicsCount += line.Split(new String[] { " " }, StringSplitOptions.RemoveEmptyEntries).Where(x => x.Contains('/')).Count();
                    testCaseTopics.AddRange(line.Split(new String[] { " " }, StringSplitOptions.RemoveEmptyEntries).Where(x => x.Contains('/')).ToList());
                }
                if (interactive)
                {
                    Console.Clear();
                    Console.Out.WriteLine((float)passedLines++ / (float)totalLines * 100 + "%");
                }
            }
            WriteTestCasesWithTopicCounts(testCaseIdWithCounts, testCaseIdWithTopics, "");
        }

        public void CountNounAndVerbCombinedForExcel(bool interactive)
        {
            var files = Directory.GetFiles(directoryForExtractedTestCases).Where(x => x.Contains("Tagged") && !x.Contains("Pairs"));
            var fileCount = 0;
            foreach (var file in files)
            {
                fileCount++;
                var contents = File.ReadAllText(file);
                var totalLines = contents.Split(new string[] { "\n" }, StringSplitOptions.RemoveEmptyEntries).Count();
                var passedLines = 0;
                int currentTestCaseID = 0;
                List<KeyValuePair<int, int>> testCaseIdWithCounts = new List<KeyValuePair<int, int>>();
                List<KeyValuePair<int, List<string>>> testCaseIdWithTopics = new List<KeyValuePair<int, List<string>>>();
                var testCaseTopicsCount = 0;
                var testCaseTopics = new List<string>();
                foreach (var line in contents.Split(new string[] { "\n" }, StringSplitOptions.RemoveEmptyEntries))
                {
                    if (line.Contains("Test Case ID: "))
                    {
                        if (currentTestCaseID != 0)
                        {
                            testCaseIdWithCounts.Add(new KeyValuePair<int, int>(currentTestCaseID, testCaseTopicsCount));
                            testCaseIdWithTopics.Add(new KeyValuePair<int, List<string>>(currentTestCaseID, testCaseTopics));
                            testCaseTopicsCount = 0;
                            testCaseTopics = new List<string>();
                        }
                        currentTestCaseID = Convert.ToInt32(line.Split(new String[] { ": " }, StringSplitOptions.RemoveEmptyEntries)[1].Split('~')[0].Replace(".html", "").Replace(".txt", ""));
                    }
                    else
                    {
                        testCaseTopicsCount += line.Split(new String[] { " " }, StringSplitOptions.RemoveEmptyEntries).Where(x => x.Contains('/')).Count();
                        testCaseTopics.AddRange(line.Split(new String[] { " " }, StringSplitOptions.RemoveEmptyEntries).Where(x => x.Contains('/')).ToList());
                    }
                    if (interactive)
                    {
                        Console.Clear();
                        Console.Out.WriteLine((float)passedLines++ / (float)totalLines * 100 + "%");
                    }
                }
                WriteTestCasesWithTopicCounts(testCaseIdWithCounts, testCaseIdWithTopics, file);
            }
        }




        public void WriteTestCasesWithTopicCounts(List<KeyValuePair<int, int>> testId_pair, List<KeyValuePair<int, List<string>>> testId_topics, string fileName)
        {
            StringBuilder fileString = new StringBuilder();
            for (var test = 0; test < testId_pair.Count; test++)
            {
                fileString.Append("id=" + testId_pair[test].Key + "\n");
                fileString.Append(string.Join(",", testId_topics[test].Value).ToLower());
                fileString.Append("\n");
                fileString.Append(testId_pair[test].Value);
                fileString.Append("\n");
            }
            if (string.IsNullOrEmpty(fileName))
                File.WriteAllText(fileToSaveTestIdWithTopicCounts, fileString.ToString());
            else
                File.WriteAllText(fileName.Substring(0, fileName.LastIndexOf(".")) + "_NounVerbTopics.txt", fileString.ToString());
        }
        public void ReadTestCasesWithTopicCounts(out List<KeyValuePair<int, int>> testId_Count, out List<KeyValuePair<int, List<string>>> testId_Topics, string fileName)
        {
            testId_Count = new List<KeyValuePair<int, int>>();
            testId_Topics = new List<KeyValuePair<int, List<string>>>();
            string testIdPairsContent = "";
            if (string.IsNullOrEmpty(fileName))
                testIdPairsContent = File.ReadAllText(fileToSaveTestIdWithTopicCounts);
            else
                testIdPairsContent = File.ReadAllText(fileName.Substring(0, fileName.LastIndexOf("_")) + "_NounVerbTopics.txt");
            var currentId = 0;
            foreach (var line in testIdPairsContent.Split(new string[] { "\n" }, StringSplitOptions.RemoveEmptyEntries))
            {
                if (line.StartsWith("id="))
                    currentId = Convert.ToInt32(line.Split('=')[1]);
                else
                {
                    int temp = 0;
                    if (int.TryParse(line, out temp))
                        testId_Count.Add(new KeyValuePair<int, int>(currentId, Convert.ToInt32(line)));
                    else
                        testId_Topics.Add(new KeyValuePair<int, List<string>>(currentId, line.Split(',').ToList()));
                }
            }
        }
        public void OrderForTopicCounts(bool interactive)
        {
            List<KeyValuePair<int, int>> testId_count = new List<KeyValuePair<int, int>>();
            List<KeyValuePair<int, List<string>>> testId_topics = new List<KeyValuePair<int, List<string>>>();
            ReadTestCasesWithTopicCounts(out testId_count, out testId_topics, "");

            //List<int> sortedTestIds = testId_count.OrderByDescending(x => x.Value).Select(x => x.Key).ToList();
            List<string> topics = (from t in testId_topics select t.Value).ToList().SelectMany(l => l).Distinct().ToList();
            List<KeyValuePair<string, int>> topicCounts = new List<KeyValuePair<string, int>>();
            //Getting counts of topics
            foreach (var t in topics)
            {
                var count = (from tests in testId_topics
                             where tests.Value.Contains(t)
                             select tests.Key).Count();
                topicCounts.Add(new KeyValuePair<string, int>(t, count));
            }


            /********Go to the result file, and replace § character with ~*********/
            var resultFile = File.ReadAllLines(fileToExtractResultsOfTestCasesFrom);
            var totalFaults = 0;
            //record results in this list, and put true if a test case passes else false for fail or bad test case
            List<KeyValuePair<int, bool>> testResults = new List<KeyValuePair<int, bool>>();
            foreach (var line in resultFile)
            {
                if (line.Contains("id="))
                {
                    var testId = Convert.ToInt32(line.Substring(line.IndexOf("id=") + 3/*for i d =*/).Split('~')[0]);
                    if (line.Substring(0, 10).Contains("Pass"))
                    {
                        testResults.Add(new KeyValuePair<int, bool>(testId, true));
                    }
                    else
                    {
                        totalFaults++;
                        testResults.Add(new KeyValuePair<int, bool>(testId, false));
                    }
                }
            }

            var originalOrder = (from t in testId_count
                                 select t.Key).ToList();

















            File.WriteAllText(fileToSaveResultForChartsNounVerbCount, "INITIATING ....................................\n\n");
            for (var indexForRandomizingResult = 0; indexForRandomizingResult < 100; indexForRandomizingResult++)
                FindMetricsForNounVerbCombined(indexForRandomizingResult, testId_count, topicCounts, testId_topics, testResults, totalFaults, originalOrder, "");



            //System.Diagnostics.Process.Start(fileToSaveResultForChartsNounVerbCount);
            ProcessStartInfo pi = new ProcessStartInfo(fileToSaveResultForChartsNounVerbCount);
            pi.Arguments = Path.GetFileName(fileToSaveResultForChartsNounVerbCount);
            pi.UseShellExecute = true;
            pi.WorkingDirectory = Path.GetDirectoryName(fileToSaveResultForChartsNounVerbCount);
            pi.FileName = @"C:\Program Files (x86)\Notepad++\\notepad++.exe";
            pi.Verb = "OPEN";
            Process.Start(pi);
















            ////CLUSTERING
            //int clusterCount = 2; var testing = Cluster(dataForClustering, clusterCount); ShowVector(testing, true); ShowClustered(dataForClustering, testing, clusterCount, 1);

            ////SHOW CLUSTERED PAIRS           //for (var c = 0; c < clusterCount; c++)            //{            //    Console.Out.WriteLine("Cluster "+ c);            //    for (var d = 0; d < testing.Count() ; d++)            //    {            //        if(testing[d] == c)            //        Console.Out.Write(PairWithIds[d]);            //    }            //    Console.Out.WriteLine("-----------------------------------------------------------------------------------------------------------------");            //    Console.Out.WriteLine("-----------------------------------------------------------------------------------------------------------------");            //    Console.Out.WriteLine("-----------------------------------------------------------------------------------------------------------------");            //    Console.Out.WriteLine("-----------------------------------------------------------------------------------------------------------------");            //    Console.Out.WriteLine("-----------------------------------------------------------------------------------------------------------------");            //}
        }



        public void OrderForTopicCountsForExcel(bool interactive)
        {
            var results = DeserializeResults(@"C:\Temp\SEALab\NLP-Project\ExtractedTestCases\LatestVersions\ExtractedObjectForAllTestResults.txt");
            var files = Directory.GetFiles(directoryForExtractedTestCases).Where(x => x.Contains("NounVerbTopics"));
            foreach (var file in files)
            {
                List<KeyValuePair<int, int>> testId_count = new List<KeyValuePair<int, int>>();
                List<KeyValuePair<int, List<string>>> testId_topics = new List<KeyValuePair<int, List<string>>>();
                ReadTestCasesWithTopicCounts(out testId_count, out testId_topics, file);

                //List<int> sortedTestIds = testId_count.OrderByDescending(x => x.Value).Select(x => x.Key).ToList();
                List<string> topics = (from t in testId_topics select t.Value).ToList().SelectMany(l => l).Distinct().ToList();
                List<KeyValuePair<string, int>> topicCounts = new List<KeyValuePair<string, int>>();
                //Getting counts of topics
                foreach (var t in topics)
                {
                    var count = (from tests in testId_topics
                                 where tests.Value.Contains(t)
                                 select tests.Key).Count();
                    topicCounts.Add(new KeyValuePair<string, int>(t, count));
                }

                #region Extracting Test Results from the File
                //extracting the results of the test cases of this litmus
                /******************************IMPORTANT*******************************/
                /********Go to the result file, and replace § character with ~*********/

                var totalFaults = 0;
                List<KeyValuePair<int, bool>> testResults = new List<KeyValuePair<int, bool>>();
                var currentFile = file.Substring(file.LastIndexOf("\\") + 1).Replace("Tagged", "").Split('~');
                var currentProduct = currentFile[0];
                var currentVersion = currentFile[1].Split('_')[0];
                foreach (var result in results.Where(x => x.Product == currentProduct && x.Version == currentVersion))
                {
                    testResults.Add(new KeyValuePair<int, bool>(result.Id, result.Result));
                }
                totalFaults = testResults.Count(x => x.Value == false);
                #endregion

                ///********Go to the result file, and replace § character with ~*********/
                //var resultFile = File.ReadAllLines(fileToExtractResultsOfTestCasesFrom);
                //var totalFaults = 0;
                ////record results in this list, and put true if a test case passes else false for fail or bad test case
                //List<KeyValuePair<int, bool>> testResults = new List<KeyValuePair<int, bool>>();
                //foreach (var line in resultFile)
                //{
                //    if (line.Contains("id="))
                //    {
                //        var testId = Convert.ToInt32(line.Substring(line.IndexOf("id=") + 3/*for i d =*/).Split('~')[0]);
                //        if (line.Substring(0, 10).Contains("Pass"))
                //        {
                //            testResults.Add(new KeyValuePair<int, bool>(testId, true));
                //        }
                //        else
                //        {
                //            totalFaults++;
                //            testResults.Add(new KeyValuePair<int, bool>(testId, false));
                //        }
                //    }
                //}

                var originalOrder = (from t in testId_count
                                     select t.Key).ToList();













                var fileToSaveResultsTo = file.Substring(0, file.LastIndexOf("\\") + 1) + "Results\\NounVerbCountMethod\\NAPFD10\\" + file.Substring(file.LastIndexOf("\\") + 1, file.LastIndexOf("_") - 1 - file.LastIndexOf("\\")).Replace("Tagged", "") + ".txt";





                if (testId_count.Count > 100)
                    File.WriteAllText(fileToSaveResultsTo, "INITIATING ....................................\n\n");
                for (var indexForRandomizingResult = 0; indexForRandomizingResult < 100; indexForRandomizingResult++)
                {
                    if (testId_count.Count > 100)
                        FindMetricsForNounVerbCombined(indexForRandomizingResult, testId_count, topicCounts, testId_topics, testResults, totalFaults, originalOrder, fileToSaveResultsTo);
                }


                //System.Diagnostics.Process.Start(fileToSaveResultForChartsNounVerbCount);
                ProcessStartInfo pi = new ProcessStartInfo(fileToSaveResultsTo);
                pi.Arguments = Path.GetFileName(fileToSaveResultsTo);
                pi.UseShellExecute = true;
                pi.WorkingDirectory = Path.GetDirectoryName(fileToSaveResultsTo);
                pi.FileName = @"C:\Program Files (x86)\Notepad++\\notepad++.exe";
                pi.Verb = "OPEN";
                Process.Start(pi);
            }















            ////CLUSTERING
            //int clusterCount = 2; var testing = Cluster(dataForClustering, clusterCount); ShowVector(testing, true); ShowClustered(dataForClustering, testing, clusterCount, 1);

            ////SHOW CLUSTERED PAIRS           //for (var c = 0; c < clusterCount; c++)            //{            //    Console.Out.WriteLine("Cluster "+ c);            //    for (var d = 0; d < testing.Count() ; d++)            //    {            //        if(testing[d] == c)            //        Console.Out.Write(PairWithIds[d]);            //    }            //    Console.Out.WriteLine("-----------------------------------------------------------------------------------------------------------------");            //    Console.Out.WriteLine("-----------------------------------------------------------------------------------------------------------------");            //    Console.Out.WriteLine("-----------------------------------------------------------------------------------------------------------------");            //    Console.Out.WriteLine("-----------------------------------------------------------------------------------------------------------------");            //    Console.Out.WriteLine("-----------------------------------------------------------------------------------------------------------------");            //}
        }



        public void FindMetricsForNounVerbCombined(int indexForIteration, List<KeyValuePair<int, int>> testId_count, List<KeyValuePair<string, int>> topicCounts, List<KeyValuePair<int, List<string>>> testId_topics, List<KeyValuePair<int, bool>> testResults, int totalFaults, List<int> originalOrder, string fileToSaveResults)
        {


            var faults = testResults.Where(x => x.Value == false);

            var faultCount = faults.Count(x => x.Value == false);

            var MyRank = new List<int>();
            MyRank.Add(testId_count.OrderByDescending(x => x.Value).ElementAt(indexForIteration).Key);
            //removing it from the list so that it doesn't get ranked again
            //no need to do this as we are already excluding the ranked ones below
            //testId_count.RemoveAt(index);















            List<string> sortedTopics = topicCounts.OrderByDescending(x => x.Value).Select(x => x.Key).ToList();
            sortedTopics = sortedTopics.Except(testId_topics.FirstOrDefault(x => x.Key == MyRank.FirstOrDefault()).Value).ToList();
            while (sortedTopics.Any())
            {
                var thisTopic = sortedTopics.FirstOrDefault();
                var testCasesCoveringThisTopic = from t in testId_topics
                                                 where t.Value.Contains(thisTopic) && !MyRank.Contains(t.Key)
                                                 select new KeyValuePair<int, int>(t.Key, t.Value.Count);
                if (testCasesCoveringThisTopic.Any())
                {
                    var bestCandidate = testCasesCoveringThisTopic.OrderByDescending(x => x.Value).FirstOrDefault();
                    MyRank.Add(bestCandidate.Key);
                    sortedTopics = sortedTopics.Except(testId_topics.FirstOrDefault(x => x.Key == bestCandidate.Key).Value).ToList();
                }
            }
            if (MyRank.Count != testId_count.Count)
            {
                var remaining = (from t in testId_count
                                 where !MyRank.Contains(t.Key)
                                 select t).OrderByDescending(x => x.Value).Select(x => x.Key).ToList();
                MyRank.AddRange(remaining);
            }


            if (string.IsNullOrEmpty(fileToSaveResults))
                File.AppendAllText(fileToSaveResultForChartsNounVerbCount, "ITERATION: " + indexForIteration + " # \n");
            else
                File.AppendAllText(fileToSaveResults, "ITERATION: " + indexForIteration + " # \n");
            ///////////////////////////PERCENTAGE OF FAULTS FOUND/////////////////////////////
            Dictionary<float, float> faultDetectedPercentage = new Dictionary<float, float>();
            //Console.In.Read();
            //calculating apfd
            var loope = 0;
            var faultsDetected = 0.0;
            var myAPFD = 1.0;
            var progress = 0.0;
            double[] apfdPrioritizedForIteration = new double[MyRank.Count];
            var indexDetectingFault = 0;
            for (var index = 0; index < MyRank.Count; index++)
            {
                var thisTest = testResults.FirstOrDefault(x => x.Key == MyRank[index]);
                if (thisTest.Key != 0 && thisTest.Value == false)
                {
                    indexDetectingFault += index;
                    myAPFD = 1 - ((float)indexDetectingFault / (float)(totalFaults * MyRank.Count)) + (float)(1 / (float)(2 * MyRank.Count));
                }
                Console.Out.WriteLine("Progress: " + progress / MyRank.Count + "%, APFD: " + myAPFD);
                apfdPrioritizedForIteration[Convert.ToInt32(progress)] = myAPFD;
                if (faults.Any(x => x.Key == MyRank[index]))//testResults.Any(x => x.Key == MyRank[index] && x.Value == false))
                {
                    faultsDetected++;
                    faultDetectedPercentage.Add((float)(progress / MyRank.Count), (float)faultsDetected / faultCount);
                }
                progress++;
            }

            //0.56019               for Litmus 40
            //0.69075774404759671   for Litmus 50  
            //0.76381420163048475   for Litmus 60  
            //0.63726620689453073   for Litmus 70  
            //0.53781461899560423   for Litmus 80



            if (string.IsNullOrEmpty(fileToSaveResults))
            {
                File.AppendAllText(fileToSaveResultForChartsNounVerbCount, "TOPIC METHOD APFD = " + myAPFD + ";");
                File.AppendAllText(fileToSaveResultForChartsNounVerbCount, "\t\t\t" + string.Join(",", faultDetectedPercentage) + "\n");
            }
            else
            {
                File.AppendAllText(fileToSaveResults, "TOPIC METHOD APFD = " + myAPFD + ";");
                File.AppendAllText(fileToSaveResults, "\t\t\t" + string.Join(",", faultDetectedPercentage) + "\n");
            }







            //FOR Random ordering
            var randomRanking = new List<int>();
            var randomNumbers = GenerateRandom(originalOrder.Count, 0, originalOrder.Count);
            List<int> alreadyUsedIndexes = new List<int>();
            foreach (var rnd in randomNumbers)
            {
                randomRanking.Add(originalOrder[rnd]);
            }


            var randomAPFD = 1.0;
            faultsDetected = 0;
            progress = 0.0;
            double[] apfdForIteration = new double[randomRanking.Count];
            indexDetectingFault = 0;
            faultDetectedPercentage = new Dictionary<float, float>();
            for (var index = 0; index < randomRanking.Count; index++)
            {
                var thisTest = testResults.FirstOrDefault(x => x.Key == randomRanking[index]);
                if (thisTest.Key != 0 && thisTest.Value == false)
                {
                    indexDetectingFault += index;
                    randomAPFD = 1 - ((float)indexDetectingFault / (float)(totalFaults * randomRanking.Count)) + (float)(1 / (float)(2 * randomRanking.Count));
                }
                Console.Out.WriteLine("Progress: " + progress / MyRank.Count + "%, APFD: " + randomAPFD);
                apfdForIteration[Convert.ToInt32(progress)] = randomAPFD;
                if (faults.Any(x => x.Key == randomRanking[index]))//testResults.Any(x => x.Key == MyRank[index] && x.Value == false))
                {
                    faultsDetected++;
                    faultDetectedPercentage.Add((float)(progress / randomRanking.Count), (float)faultsDetected / faultCount);
                }
                progress++;
            }

            //Console.In.Read();







            if (string.IsNullOrEmpty(fileToSaveResults))
            {
                File.AppendAllText(fileToSaveResultForChartsNounVerbCount, "RANDOM METHOD APFD = " + randomAPFD + ";");
                File.AppendAllText(fileToSaveResultForChartsNounVerbCount, "\t\t\t" + string.Join(",", faultDetectedPercentage) + "\n");
            }
            else
            {
                File.AppendAllText(fileToSaveResults, "RANDOM METHOD APFD = " + randomAPFD + ";");
                File.AppendAllText(fileToSaveResults, "\t\t\t" + string.Join(",", faultDetectedPercentage) + "\n");
            }

        }
        #endregion









		
        #region Clustering


        static void ShowVector(int[] vector, bool newLine)
        {
            String fileString = "";
            for (int i = 0; i < vector.Length; ++i)
            {
                Console.Write(vector[i] + " ");
                fileString += vector[i] + " ";
            }
            if (newLine)
            {
                Console.WriteLine("\n");
                fileString += "\n";
            }
            File.WriteAllText(@"C:\Temp\CLUSTERINGOUTPUT.txt", fileString);
        }

        static void ShowClustered(double[][] data, int[] clustering, int numClusters, int decimals)
        {
            string fileString = "";
            for (int k = 0; k < numClusters; ++k)
            {
                fileString += "===================" + "\n";
                Console.WriteLine("===================");
                for (int i = 0; i < data.Length; ++i)
                {
                    int clusterID = clustering[i];
                    if (clusterID != k) continue;
                    Console.Write(i.ToString().PadLeft(3) + " ");
                    fileString += i.ToString().PadLeft(3) + " ";
                    for (int j = 0; j < data[i].Length; ++j)
                    {
                        if (data[i][j] >= 0.0) Console.Write(" ");
                        Console.Write(data[i][j].ToString("F" + decimals) + " ");
                        fileString += data[i][j].ToString("F" + decimals) + " ";
                    }
                    Console.WriteLine("");
                    fileString += "\n";
                }
                Console.WriteLine("===================");
                fileString += "===================" + "\n";
            } // k

            File.AppendAllText(@"C:\Temp\CLUSTERINGOUTPUT.txt", "\n\n\n\n\n\n\n\n\n\n" + fileString);
        }

        public static int[] Cluster(double[][] rawData, int numClusters)
        {
            // k-means clustering
            // index of return is tuple ID, cell is cluster ID
            // ex: [2 1 0 0 2 2] means tuple 0 is cluster 2, tuple 1 is cluster 1, tuple 2 is cluster 0, tuple 3 is cluster 0, etc.
            // an alternative clustering DS to save space is to use the .NET BitArray class
            double[][] data = Normalized(rawData); // so large values don't dominate

            bool changed = true; // was there a change in at least one cluster assignment?
            bool success = true; // were all means able to be computed? (no zero-count clusters)

            // init clustering[] to get things started
            // an alternative is to initialize means to randomly selected tuples
            // then the processing loop is
            // loop
            //    update clustering
            //    update means
            // end loop
            int[] clustering = InitClustering(data.Length, numClusters, 0); // semi-random initialization
            double[][] means = Allocate(numClusters, data[0].Length); // small convenience

            int maxCount = data.Length * 10; // sanity check
            int ct = 0;
            while (changed == true && success == true && ct < maxCount)
            {
                ++ct; // k-means typically converges very quickly
                success = UpdateMeans(data, clustering, means); // compute new cluster means if possible. no effect if fail
                changed = UpdateClustering(data, clustering, means); // (re)assign tuples to clusters. no effect if fail
            }
            // consider adding means[][] as an out parameter - the final means could be computed
            // the final means are useful in some scenarios (e.g., discretization and RBF centroids)
            // and even though you can compute final means from final clustering, in some cases it
            // makes sense to return the means (at the expense of some method signature uglinesss)
            //
            // another alternative is to return, as an out parameter, some measure of cluster goodness
            // such as the average distance between cluster means, or the average distance between tuples in 
            // a cluster, or a weighted combination of both
            return clustering;
        }

        //FINDING DISTANCE OF SOME SORT
        private static double[][] Normalized(double[][] rawData)
        {
            // normalize raw data by computing (x - mean) / stddev
            // primary alternative is min-max:
            // v' = (v - min) / (max - min)

            // make a copy of input data
            double[][] result = new double[rawData.Length][];
            for (int i = 0; i < rawData.Length; ++i)
            {
                result[i] = new double[rawData[i].Length];
                Array.Copy(rawData[i], result[i], rawData[i].Length);
            }

            //FOR EACH COLUMN
            for (int j = 0; j < result[0].Length; ++j) // each col
            {
                //TAKE COLUMN SUM
                double colSum = 0.0;
                for (int i = 0; i < result.Length; ++i)
                    colSum += result[i][j];
                //TAKE MEAN OF THAT COLUMN
                double mean = colSum / result.Length;
                //FIND STANDARD DEVIATION Sum of Xi-Xmean^2 / N
                double sum = 0.0;
                for (int i = 0; i < result.Length; ++i)
                    sum += (result[i][j] - mean) * (result[i][j] - mean);
                double sd = sum / result.Length;
                //VALUE - MEAN / STANDARD DEVIATION
                for (int i = 0; i < result.Length; ++i)
                    result[i][j] = (result[i][j] - mean) / sd;
            }
            return result;
        }

        private static int[] InitClustering(int numTuples, int numClusters, int randomSeed)
        {
            // init clustering semi-randomly (at least one tuple in each cluster)
            // consider alternatives, especially k-means++ initialization,
            // or instead of randomly assigning each tuple to a cluster, pick
            // numClusters of the tuples as initial centroids/means then use
            // those means to assign each tuple to an initial cluster.
            System.Random random = new System.Random(randomSeed);
            int[] clustering = new int[numTuples];
            for (int i = 0; i < numClusters; ++i) // make sure each cluster has at least one tuple
                clustering[i] = i;
            for (int i = numClusters; i < clustering.Length; ++i)
                clustering[i] = random.Next(0, numClusters); // other assignments random
            return clustering;
        }

        private static double[][] Allocate(int numClusters, int numColumns)
        {
            // convenience matrix allocator for Cluster()
            double[][] result = new double[numClusters][];
            for (int k = 0; k < numClusters; ++k)
                result[k] = new double[numColumns];
            return result;
        }

        private static bool UpdateMeans(double[][] data, int[] clustering, double[][] means)
        {
            // returns false if there is a cluster that has no tuples assigned to it
            // parameter means[][] is really a ref parameter

            // check existing cluster counts
            // can omit this check if InitClustering and UpdateClustering
            // both guarantee at least one tuple in each cluster (usually true)
            int numClusters = means.Length;
            int[] clusterCounts = new int[numClusters];
            for (int i = 0; i < data.Length; ++i)
            {
                int cluster = clustering[i];
                ++clusterCounts[cluster];
            }

            for (int k = 0; k < numClusters; ++k)
                if (clusterCounts[k] == 0)
                    return false; // bad clustering. no change to means[][]

            // update, zero-out means so it can be used as scratch matrix 
            for (int k = 0; k < means.Length; ++k)
                for (int j = 0; j < means[k].Length; ++j)
                    means[k][j] = 0.0;

            for (int i = 0; i < data.Length; ++i)
            {
                int cluster = clustering[i];
                for (int j = 0; j < data[i].Length; ++j)
                    means[cluster][j] += data[i][j]; // accumulate sum
            }

            for (int k = 0; k < means.Length; ++k)
                for (int j = 0; j < means[k].Length; ++j)
                    means[k][j] /= clusterCounts[k]; // danger of div by 0
            return true;
        }

        private static bool UpdateClustering(double[][] data, int[] clustering, double[][] means)
        {
            // (re)assign each tuple to a cluster (closest mean)
            // returns false if no tuple assignments change OR
            // if the reassignment would result in a clustering where
            // one or more clusters have no tuples.

            int numClusters = means.Length;
            bool changed = false;

            int[] newClustering = new int[clustering.Length]; // proposed result
            Array.Copy(clustering, newClustering, clustering.Length);

            double[] distances = new double[numClusters]; // distances from curr tuple to each mean

            for (int i = 0; i < data.Length; ++i) // walk thru each tuple
            {
                for (int k = 0; k < numClusters; ++k)
                    distances[k] = Distance(data[i], means[k]); // compute distances from curr tuple to all k means

                int newClusterID = MinIndex(distances); // find closest mean ID
                if (newClusterID != newClustering[i])
                {
                    changed = true;
                    newClustering[i] = newClusterID; // update
                }
            }

            if (changed == false)
                return false; // no change so bail and don't update clustering[][]

            // check proposed clustering[] cluster counts
            int[] clusterCounts = new int[numClusters];
            for (int i = 0; i < data.Length; ++i)
            {
                int cluster = newClustering[i];
                ++clusterCounts[cluster];
            }

            for (int k = 0; k < numClusters; ++k)
                if (clusterCounts[k] == 0)
                    return false; // bad clustering. no change to clustering[][]

            Array.Copy(newClustering, clustering, newClustering.Length); // update
            return true; // good clustering and at least one change
        }

        private static double Distance(double[] tuple, double[] mean)
        {
            // Euclidean distance between two vectors for UpdateClustering()

            double sumSquaredDiffs = 0.0;
            for (int j = 0; j < tuple.Length; ++j)
                sumSquaredDiffs += Math.Pow((tuple[j] - mean[j]), 2);
            return Math.Sqrt(sumSquaredDiffs);
        }

        private static int MinIndex(double[] distances)
        {
            // index of smallest value in array
            // helper for UpdateClustering()
            int indexOfMin = 0;
            double smallDist = distances[0];
            for (int k = 0; k < distances.Length; ++k)
            {
                if (distances[k] < smallDist)
                {
                    smallDist = distances[k];
                    indexOfMin = k;
                }
            }
            return indexOfMin;
        }
        #endregion







		
        #region Statechum Helper Code
        public void ProcessTrace()
        {
            var functionNames = new string[] { "calculatePidCore2", "interpolatePIDgain", "GetPidDTermIsHdgRate", "GetPidRate", "endPidTransition", "initiatePidTransition", "smoothPidTransition", "pidTransitionInProcess", "pidSmoothingFirstSample", "GetPidDTermLPF", "getPIDshift" };
            //var functionName = "endPidTransition";
            foreach (var functionName in functionNames)
            {
                var traceContent = File.ReadAllLines(@"C:\Temp\Test3trace.txt");
                List<int> enterIndices = new List<int>();
                List<int> exitIndices = new List<int>();
                int lineNumber = 0;
                foreach (var line in traceContent)
                {
                    if (line.Contains(@"Enter -> int " + functionName) || line.Contains(@"Enter -> void " + functionName))
                    {
                        enterIndices.Add(lineNumber);
                    }
                    if (line.Contains(@"Exit <- int " + functionName) || line.Contains(@"Exit <- void " + functionName))
                    {
                        exitIndices.Add(lineNumber);
                    }
                    lineNumber++;
                }
                List<string> functionEnterLines = new List<string>();
                for (var a = 0; a < enterIndices.Count; a++)
                {
                    for (var i = enterIndices[a]; i <= exitIndices[a]; i++)
                    {
                        if (traceContent[i].Contains("Enter ->"))
                            functionEnterLines.Add(traceContent[i]);
                    }
                }
                File.WriteAllLines(@"C:\TEMP\Trace3ExtractedFunctions\" + functionName + ".txt", functionEnterLines);
            }
        }
        #endregion








		

        #region Count stats for data from new script views
        public void AnalyzeResultFiles()
        {
            var result = File.ReadAllLines(@"C:\Temp\SEALab\NLP-Project\MySqlTests-NewVersions\all_versions_steps_result.csv");
            File.WriteAllText(@"C:\Temp\Mobile_Statistics_OnlyFaults_new.txt", "");
            Dictionary<int, int> VersionFaults = new Dictionary<int, int>();
            List<KeyValuePair<int, int>> VersionTestIds = new List<KeyValuePair<int, int>>();
            foreach (var line in result)
            {
                var temp = line.Split(',');

                var version = Convert.ToInt32(temp[0]);
                var testId = Convert.ToInt32(temp[1]);
                if (!VersionTestIds.Any(x => x.Key == version && x.Value == testId))
                {
                    if (VersionFaults.Any(x => x.Key == version))
                    {
                        VersionFaults[version]++;
                    }
                    else
                    {
                        VersionFaults.Add(version, 1);
                    }
                    VersionTestIds.Add(new KeyValuePair<int, int>(version, testId));
                }
            }
            foreach (var version in VersionFaults.Select(x => x.Key))
            {
                File.AppendAllText(@"C:\Temp\Mobile_Statistics_OnlyFaults_new.txt", "Version: " + version + ";\tFailing: " + VersionFaults[version] + Environment.NewLine);
            }

        }
        public void CreateResultFilesByVersion()
        {
            var genericFolderToSaveResultFile = @"C:\Temp\SEALab\NLP-Project\ExtractedTestCases\mobile_@@_Result.txt";
            var result = File.ReadAllLines(@"C:\Temp\SEALab\NLP-Project\MySqlTests-NewVersions\all_versions_steps_result.csv");
            Dictionary<int, int> VersionFaults = new Dictionary<int, int>();
            Dictionary<int, List<int>> VersionTestIds = new Dictionary<int, List<int>>();
            foreach (var line in result)
            {
                var temp = line.Split(',');

                var version = Convert.ToInt32(temp[0]);
                var testId = Convert.ToInt32(temp[1]);
                if (!VersionTestIds.Any(x => x.Key == version && x.Value.Contains(testId)))
                {
                    if (VersionFaults.Any(x => x.Key == version))
                    {
                        VersionFaults[version]++;
                    }
                    else
                    {
                        VersionFaults.Add(version, 1);
                    }
                    if (!VersionTestIds.Any(x => x.Key == version))
                        VersionTestIds.Add(version, new List<int> { testId });
                    else
                    {
                        var temp2 = VersionTestIds[version];
                        temp2.Add(testId);
                        VersionTestIds[version] = temp2;
                    }
                }
            }
            foreach (var version in VersionTestIds.Select(x => x.Key))
            {
                File.WriteAllText(genericFolderToSaveResultFile.Replace("@@", version.ToString()), "");
                foreach (var id in VersionTestIds[version])
                {
                    File.AppendAllText(genericFolderToSaveResultFile.Replace("@@", version.ToString()), "[" + id + " " + "False]" + Environment.NewLine);
                }

            }

        }
        public void AnalyzeTestCaseFiles()
        {
            var steps = File.ReadAllLines(@"C:\Temp\SEALab\NLP-Project\MySqlTests-NewVersions\all_versions_steps_view.csv");
            File.WriteAllText(@"C:\Temp\Mobile_Statistics_TotalTestCases_new.txt", "");
            Dictionary<int, int> VersionFaults = new Dictionary<int, int>();
            List<KeyValuePair<int, int>> VersionTestIds = new List<KeyValuePair<int, int>>();
            List<KeyValuePair<int, KeyValuePair<int, string>>> VersionTestIdInstruction = new List<KeyValuePair<int, KeyValuePair<int, string>>>();
            int t = 0;
            foreach (var line in steps)
            {
                if (!string.IsNullOrEmpty(line) && line.Split(',').Length == 3 && int.TryParse(line.Split(',')[0], out t) && int.TryParse(line.Split(',')[1], out t))
                {
                    var temp = line.Split(',');
                    var version = Convert.ToInt32(temp[0]);
                    var testId = Convert.ToInt32(temp[1]);
                    var instruction = temp[2];
                    if (!VersionTestIds.Any(x => x.Key == version && x.Value == testId) && !VersionTestIdInstruction.Any(x => x.Key == version && x.Value.Value == StripSpecialCharacters(instruction).Replace(" ", "").ToLower()))
                    {
                        if (VersionFaults.Any(x => x.Key == version))
                        {
                            VersionFaults[version]++;
                        }
                        else
                        {
                            VersionFaults.Add(version, 1);
                        }
                        VersionTestIds.Add(new KeyValuePair<int, int>(version, testId));
                        VersionTestIdInstruction.Add(new KeyValuePair<int, KeyValuePair<int, string>>(version, new KeyValuePair<int, string>(testId, StripSpecialCharacters(instruction).Replace(" ", "").ToLower())));
                    }
                }
            }
            foreach (var version in VersionFaults.Select(x => x.Key))
            {
                File.AppendAllText(@"C:\Temp\Mobile_Statistics_TotalTestCases_new.txt", "Version: " + version + ";\tTestCases: " + VersionFaults[version] + Environment.NewLine);
            }

        }
        #endregion